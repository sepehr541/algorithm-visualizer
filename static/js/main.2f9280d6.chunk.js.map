{"version":3,"sources":["grid/Grid.module.css","controlbar/ControlBar.module.css","ItemTypes.js","Constants.js","grid/Grid.js","controlbar/ControlBar.js","path-finding-algorithms/Utils.js","path-finding-algorithms/MinHeap.js","path-finding-algorithms/GenericBFS.js","path-finding-algorithms/Heuristics.js","path-finding-algorithms/index.js","path-finding-algorithms/Dijkstra.js","path-finding-algorithms/GreedyBFS.js","path-finding-algorithms/AStar.js","path-finding-algorithms/DFS.js","maze-algorithms/RecursiveDivision.js","App.js","index.js"],"names":["module","exports","ItemTypes","EMPTY","SOURCE","DEST","WALL","WIDTH","HEIGHT","IconMap","source","dest","Draggable","type","useDrag","item","collect","monitor","isDragging","drag","ref","addRemoveWall","coords","setWall","removeWall","ItemType","Cell","handleDrop","isMouseDown","setMouseDown","handleIsOver","useDrop","accept","drop","isOver","itemType","getItemType","isWall","useEffect","id","i","j","isEmpty","className","classNames","styles","cell","wall","onMouseDown","onMouseEnter","onMouseUp","Grid","setSource","setDest","getType","handleRedrawOnReposition","dropCoords","useState","draggable","onMouseLeave","grid","_","range","map","row","ControlBar","algKeys","setAlg","runAlg","clear","generateMaze","controlbar","onChange","e","target","value","key","onClick","getPath","end","path","push","parent","getNeighbors","matrix","result","sameRow","left","right","upRow","downRow","walls","find","isEqual","MinHeap","comparator","this","heap","heapify","n","length","elm","pop","delete","Math","floor","l","r","min","temp","console","log","slice","GenericBFS","start","costFunction","nodeMap","distance","Infinity","startNode","queue","insert","visited","isVisited","curr","forEach","neighbor","reverse","Manhattan","a","b","abs","AlgMap","Dijkstra","GreedyBFS","h","AStar","p","DFS","stack","shift","unshift","rand","random","Orientation","HOR","VER","chooseOrientation","width","height","makeWalls","col","hole","isHor","res","filter","eq","RecursiveDivision","orientation","wallRow","heightOne","heightTwo","newWalls","divOne","divTwo","union","wallColumn","widthOne","widthTwo","GenerateMaze","paintCellsAnimated","cellsToPaint","duration","Promise","all","document","getElementById","resolve","setTimeout","classList","add","paintInstantly","isPath","clearPaint","remove","animate","runAlgorithmAnimated","alg","runAlgorithmInstant","App","setWalls","isAnimated","setAnimated","AlgKeys","Object","keys","DndProvider","backend","HTML5Backend","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2f9280d6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"cell\":\"Grid_cell__Kf9eg\",\"wall\":\"Grid_wall__1vTvv\",\"row\":\"Grid_row__22DTu\",\"grid\":\"Grid_grid__2VjZ9\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"controlbar\":\"ControlBar_controlbar__2YUfh\"};","const ItemTypes = {\n    EMPTY: 'empty',\n    SOURCE: 'source',\n    DEST: 'dest',\n    WALL: 'wall'\n};\n\nexport default ItemTypes;","export const WIDTH = 20;\nexport const HEIGHT = 10;\n","import React, { useEffect, useState } from 'react';\nimport _ from 'lodash';\nimport classNames from 'classnames';\nimport styles from './Grid.module.css';\nimport { useDrag, useDrop } from 'react-dnd';\nimport ItemType from '../ItemTypes';\nimport { WIDTH, HEIGHT } from '../Constants';\n\nconst IconMap = {\n    source: '🏎️',\n    dest: '🏁'\n}\n\nconst Draggable = ({ type }) => {\n    const [{ isDragging }, drag] = useDrag(() => ({\n        type,\n        item: { type },\n        collect: (monitor) => ({\n            isDragging: !!monitor.isDragging()\n        })\n    }), [type]);\n    return !isDragging && <div ref={drag}>{IconMap[type]}</div>;\n}\n\nconst addRemoveWall = (type, coords, setWall, removeWall) => {\n    if (type === ItemType.WALL) {\n        removeWall(coords);\n    } else if (type === ItemType.EMPTY) {\n        setWall(coords);\n    }\n}\n\nconst Cell = ({ coords, type, handleDrop, isMouseDown, setMouseDown, setWall, removeWall, handleIsOver }) => {\n    const [{ isOver, itemType }, drop] = useDrop(\n        () => ({\n            accept: [ItemType.SOURCE, ItemType.DEST],\n            drop: (item) => handleDrop(item, coords),\n            collect: monitor => ({\n                isOver: monitor.isOver(),\n                itemType: monitor.getItemType()\n            })\n        }), []);\n\n    const isWall = type === ItemType.WALL;\n    useEffect(() => {\n        if (isOver && !isWall) {\n            handleIsOver(itemType, coords);\n        }\n    }, [isOver, handleIsOver, itemType, coords, isWall])\n    const id = `${coords.i}.${coords.j}`;\n    const isEmpty = type === ItemType.EMPTY;\n    return <div\n        ref={drop}\n        id={id}\n        className={classNames(styles.cell, isWall && styles.wall)}\n        onMouseDown={() => {\n            if (isWall || isEmpty) {\n                setMouseDown(true);\n                addRemoveWall(type, coords, setWall, removeWall);\n            }\n        }}\n        onMouseEnter={() => {\n            if (isMouseDown) {\n                addRemoveWall(type, coords, setWall, removeWall);\n            }\n        }}\n        onMouseUp={() => {\n            setMouseDown(false);\n        }}\n    >\n        {!isWall && !isEmpty && <Draggable type={type} />}\n    </div>;\n};\n\nconst Grid = ({ setSource, setDest, setWall, removeWall, getType, handleRedrawOnReposition }) => {\n    const handleDrop = (item, dropCoords) => {\n        const { type } = item;\n        if (type === ItemType.SOURCE) {\n            setSource(dropCoords);\n        } else if (type === ItemType.DEST) {\n            setDest(dropCoords);\n        }\n    }\n    const [isMouseDown, setMouseDown] = useState(false);\n    return <>\n        <div\n            draggable={false}\n            onMouseLeave={() => setMouseDown(false)}\n            className={styles.grid}\n        >\n            {_.range(HEIGHT).map(i => <div key={i} className={styles.row}>{\n                _.range(WIDTH).map(j => <Cell\n                    key={`${i}.${j}`}\n                    coords={{ i, j }}\n                    type={getType({ i, j })}\n                    handleDrop={handleDrop}\n                    isMouseDown={isMouseDown}\n                    setMouseDown={setMouseDown}\n                    removeWall={removeWall}\n                    setWall={setWall}\n                    handleIsOver={handleRedrawOnReposition}\n                />\n                )}\n            </div>)\n            }\n        </div>\n    </>\n};\n\nexport default Grid;","import React from 'react';\nimport styles from './ControlBar.module.css';\n\nfunction ControlBar({ algKeys, setAlg, runAlg, clear, generateMaze }) {\n    return (\n        <div  className={styles.controlbar}>\n            <select onChange={e => setAlg(e.target.value)}>\n                {algKeys.map(key => <option key={key} value={key}>{key}</option>)}\n            </select>\n            <button onClick={() => runAlg()}>Run Algorithm</button>\n            <button onClick={() => clear()}>Reset</button>\n            <button onClick={() => generateMaze()}>Generate Maze</button>\n        </div>\n    );\n}\n\nexport default ControlBar;","import _ from 'lodash';\nimport ItemTypes from '../ItemTypes';\n\nexport const getPath = (end, dest) => {\n    const path = [];\n    if (end.i === dest.i && end.j === dest.j) {\n        while (end) {\n            path.push(end);\n            end = end.parent;\n        }\n    }\n    return path;\n}\n\nexport const getNeighbors = (matrix, i, j) => {\n    const result = [];\n    const sameRow = matrix[i];\n    const left = sameRow[j - 1], right = sameRow[j + 1];\n    if (right) result.push(right);\n    if (left) result.push(left);\n\n    const upRow = matrix[i - 1];\n    if (upRow && upRow[j]) result.push(upRow[j]);\n\n    const downRow = matrix[i + 1];\n    if (downRow && downRow[j]) result.push(downRow[j]);\n    return result;\n};\n\nexport const isWall = (walls, coords) => {\n    return !! _.find(walls, wall => _.isEqual(coords, wall));\n};\n\nexport const isPath = (path, coords) => {\n    return _.find(path, p => p.i === coords.i && p.j === coords.j);\n}\n\nexport const getType = (coords, walls, source, dest) => {\n    if (isWall(walls, coords)) {\n        return ItemTypes.WALL;\n    } else if (_.isEqual(coords, source)) {\n        return ItemTypes.SOURCE;\n    } else if (_.isEqual(coords, dest)) {\n        return ItemTypes.DEST;\n    }\n    return ItemTypes.EMPTY;\n};\n","export default class MinHeap {\n    constructor(comparator) {\n        // make it 1-based indexed\n        this.heap = [null];\n        this.comparator = comparator;\n    }\n\n    insert(value) {\n        this.heap.push(value);\n        this.heapify();\n    }\n\n    delete(i) {\n        let n = this.heap.length;\n        if (i > 0 && n > 1) {\n            const elm = this.heap[i];\n            this.heap[i] = this.heap[n - 1];\n            this.heap.pop();\n            this.heapify();\n            return elm;\n        }\n        return null;\n    }\n\n    peek() {\n        return this.heap[1];\n    }\n\n    pop() {\n        return this.delete(1);\n    }\n\n    heapify() {\n        const n = this.heap.length;\n        let i = Math.floor((n - 1) / 2);\n        while (i >= 1) {\n            const l = (i * 2);\n            const r = l + 1;\n            let min = i;\n            if (this.comparator(this.heap[l], this.heap[min])) min = l;\n            if (this.comparator(this.heap[r], this.heap[min])) min = r;\n    \n            // swap\n            const temp = this.heap[min];\n            this.heap[min] = this.heap[i];\n            this.heap[i] = temp;\n    \n            i--;\n        }\n    };\n\n    print() {\n        console.log(this.heap.slice(1, 4));\n    }\n\n    length() {\n        return this.heap.length - 1;\n    }\n};\n","import MinHeap from './MinHeap';\nimport { getNeighbors, getPath, isWall } from './Utils';\nimport { WIDTH, HEIGHT} from '../Constants';\nimport _ from 'lodash';\n\nconst GenericBFS = (walls, start, dest, costFunction) => {\n    const nodeMap = _.range(HEIGHT).map(i => _.range(WIDTH).map(j => ({\n            i, j, distance: Infinity, isWall: isWall(walls, { i, j })\n        })\n    ));\n    const startNode = nodeMap[start.i][start.j];\n    startNode.distance = 0;\n    \n    const queue = new MinHeap(costFunction);\n    queue.insert(startNode);\n    \n    const visited = [];\n    while (queue.length() !== 0) {\n        const { i, j, isVisited, isWall } = queue.pop();\n\n        if (isWall) continue;\n        const curr = nodeMap[i][j];\n        if (i === dest.i && j === dest.j) {\n            visited.push(curr);\n            break;\n        }\n\n        if (!isVisited) {\n            const neighbors = getNeighbors(nodeMap, i, j);\n            neighbors.forEach(neighbor => {\n                if (curr.distance + 1 < neighbor.distance) {\n                    neighbor.parent = curr;\n                    neighbor.distance = curr.distance + 1;\n                }\n                if (!neighbor.isVisited) {\n                    queue.insert(neighbor);\n                }\n            })\n            curr.isVisited = true;\n            visited.push(curr);\n        }\n    }\n\n    const path = getPath(visited[visited.length - 1], dest);\n    return [visited, path.reverse()];\n}\n\nexport default GenericBFS;","export const Manhattan = (a, b) => {\n    return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);\n};\n\nexport const PointDistance = (a, b) => {\n    return Math.floor(\n        Math.sqrt(\n            Math.pow((b.i - a.i), 2) +\n            Math.pow((b.j - a.j), 2)\n        ));\n};\n\n","import Dijkstra from \"./Dijkstra\";\nimport GreedyBFS from \"./GreedyBFS\";\nimport AStar from \"./AStar\";\nimport DFS from \"./DFS\";\n\nconst AlgMap = {\n    Dijkstra,\n    GreedyBFS,\n    AStar,\n    DFS\n}\n\nexport default AlgMap;","import GenericBFS from \"./GenericBFS\";\n\nconst Dijkstra = (matrix, start, dest) => {\n    const costFunction = (i, j) => i && j && i.distance < j.distance;\n    return GenericBFS(matrix, start, dest, costFunction);\n}\n\nexport default Dijkstra;","import { Manhattan as h } from './Heuristics';\nimport GenericBFS from './GenericBFS';\n\nconst GreedyBFS = (matrix, start, dest) => {\n    const costFunction = (a, b) => a && b && h(a, dest) < h(b, dest);\n    return GenericBFS(matrix, start, dest, costFunction);\n}\n\nexport default GreedyBFS;","import { Manhattan as h } from './Heuristics';\nimport GenericBFS from './GenericBFS';\n\nconst AStar = (matrix, start, dest) => {\n    const maxDist = h(start, dest);\n    const p = 1 / maxDist;\n    const costFunction = (a, b) => a && b && h(a, dest) * (1 + p) + a.distance < h(b, dest) * (1 + p) + b.distance;\n    return GenericBFS(matrix, start, dest, costFunction);\n}\n\nexport default AStar;","import { getNeighbors, getPath, isWall } from './Utils';\nimport { WIDTH, HEIGHT} from '../Constants';\nimport _ from 'lodash';\n\nconst DFS = (walls, start, dest) => {\n    const nodeMap = _.range(HEIGHT).map(i => _.range(WIDTH).map(j => ({\n            i, j, distance: Infinity, isWall: isWall(walls, { i, j })\n        })\n    ));\n    const startNode = nodeMap[start.i][start.j];\n    startNode.distance = 0;\n    \n    const stack = [];\n    stack.push(startNode);\n    \n    const visited = [];\n    while (stack.length !== 0) {\n        const { i, j, isVisited, isWall } = stack.shift();\n\n        if (isWall) continue;\n        const curr = nodeMap[i][j];\n        if (i === dest.i && j === dest.j) {\n            visited.push(curr);\n            break;\n        }\n\n        if (!isVisited) {\n            const neighbors = getNeighbors(nodeMap, i, j);\n            neighbors.forEach(neighbor => {\n                if (curr.distance + 1 < neighbor.distance) {\n                    neighbor.parent = curr;\n                    neighbor.distance = curr.distance + 1;\n                }\n                if (!neighbor.isVisited) {\n                    stack.unshift(neighbor);\n                }\n            })\n            curr.isVisited = true;\n            visited.push(curr);\n        }\n    }\n\n    const path = getPath(visited[visited.length - 1], dest);\n    return [visited, path.reverse()];\n}\n\nexport default DFS;","/**\n * source\n * http://weblog.jamisbuck.org/2011/1/12/maze-generation-recursive-division-algorithm\n */\n\nimport _ from \"lodash\";\n\nconst rand = (range) => {\n    let rand = Math.floor(Math.random() * range);\n    return rand;\n}\n\nconst Orientation = {\n    HOR: 'hor',\n    VER: 'ver'\n}\n\n\nconst chooseOrientation = (width, height) => {\n    if (width < height) {\n        return Orientation.HOR\n    } else if (height < width) {\n        return Orientation.VER\n    } else {\n        return Orientation[rand(2)];\n    }\n};\n\nconst makeWalls = (row, col, hole, width, height, isHor, start, end) => {\n    const res = [];\n    if (isHor) {\n        while (col < width) {\n            if (col !== hole) {\n                res.push({\n                    i: row,\n                    j: col\n                })\n            }\n            col++;\n        }\n    } else {\n        while (row < height) {\n            if (row !== hole) {\n                res.push({\n                    i: row,\n                    j: col\n                })\n            }\n            row++;\n        }\n    }\n    return res.filter(wall => !_.eq(wall, start) && !_.eq(wall, end));\n}\n\nconst GenerateMaze = (row, col, width, height, start, end) => {\n    return RecursiveDivision(row, col, width, height, Orientation.VER, start, end);\n}\n\nconst RecursiveDivision = (row, col, width, height, orientation, start, end) => {\n    if (width < 3 || height < 3) return [];\n    const isHor = orientation === Orientation.HOR;\n    if (isHor) {\n        const wallRow = row + Math.floor(height / 2);\n        const hole = col + rand(width);\n        const heightOne = wallRow - row, heightTwo = height - wallRow;\n        const newWalls = makeWalls(wallRow, col, hole, width, height, isHor, start, end);\n        const divOne = RecursiveDivision(row, col, width, heightOne, chooseOrientation(width, heightOne), start, end);\n        const divTwo = RecursiveDivision(wallRow + 1, col, width, heightTwo, chooseOrientation(width, heightTwo), start, end);\n        return _.union(newWalls, divOne, divTwo);\n    } else {\n        const wallColumn = col + Math.floor(width / 2);\n        const hole = row + rand(height);\n        const widthOne = wallColumn - col, widthTwo = width - wallColumn;\n        const newWalls = makeWalls(row, wallColumn, hole, width, height, isHor, start, end);\n        const divOne = RecursiveDivision(row, col, widthOne, height, chooseOrientation(widthOne, height), start, end);\n        const divTwo = RecursiveDivision(row, wallColumn + 1, widthTwo, height, chooseOrientation(widthTwo, height), start, end);\n        return _.union(newWalls, divOne, divTwo);\n    }\n}\n\nexport default GenerateMaze;","import React, { useState } from 'react';\nimport { DndProvider } from 'react-dnd'\nimport { HTML5Backend } from 'react-dnd-html5-backend'\n\nimport './App.css';\nimport Grid from './grid/Grid';\nimport ControlBar from './controlbar/ControlBar';\nimport { WIDTH, HEIGHT } from './Constants';\nimport { getType } from './path-finding-algorithms/Utils';\nimport ItemTypes from './ItemTypes';\nimport AlgMap from './path-finding-algorithms/index';\nimport { isPath } from './path-finding-algorithms/Utils';\nimport GenerateMaze from './maze-algorithms/RecursiveDivision';\n\nconst paintCellsAnimated = (cellsToPaint, duration, className) => {\n  return Promise.all(cellsToPaint.map((cell, i) => {\n    const elm = document.getElementById(`${cell.i}.${cell.j}`);\n    return new Promise((resolve) => setTimeout(() => {\n      elm.classList.add(className);\n      resolve()\n    }, duration * i));\n  }));\n};\n\nconst paintInstantly = (visited, path) => {\n  visited.forEach(cell => {\n    const elm = document.getElementById(`${cell.i}.${cell.j}`);\n    elm.classList.add(isPath(path, cell) ? 'pathInstant' : 'visitedInstant');\n  });\n};\n\nconst clearPaint = () => {\n  for (let i = 0; i < HEIGHT; i++) {\n    for (let j = 0; j < WIDTH; j++) {\n      const elm = document.getElementById(`${i}.${j}`);\n      elm.classList.remove('visited');\n      elm.classList.remove('path');\n      elm.classList.remove('visitedInstant');\n      elm.classList.remove('pathInstant');\n    }\n  }\n};\n\nconst animate = async (visited, path) => {\n  await paintCellsAnimated(visited, 25, 'visited');\n  await paintCellsAnimated(path, 30, 'path');\n}\n\nconst runAlgorithmAnimated = async (alg, walls, start, end) => {\n  const [visited, path] = alg(walls, start, end);\n  await animate(visited, path);\n};\n\nconst runAlgorithmInstant = (alg, walls, start, end) => {\n  const [visited, path] = alg(walls, start, end);\n  clearPaint();\n  paintInstantly(visited, path);\n};\n\nfunction App() {\n  const [source, setSource] = useState({ i: 0, j: 0 });\n  const [dest, setDest] = useState({ i: HEIGHT - 1, j: WIDTH - 1 });\n  const [walls, setWalls] = useState([]);\n  const [isAnimated, setAnimated] = useState(false);\n  const setWall = (coords) => {\n    const newWalls = [...walls];\n    newWalls.push(coords);\n    setWalls(newWalls);\n  }\n  const removeWall = (coords) => {\n    const newWalls = walls.filter(wall => !(wall.i === coords.i && wall.j === coords.j));\n    setWalls(newWalls);\n  }\n\n  const AlgKeys = Object.keys(AlgMap);\n  const [alg, setAlg] = useState(AlgKeys[0]);\n  const clear = () => {\n    setAnimated(false);\n    setWalls([]);\n    clearPaint();\n  };\n\n  return <DndProvider backend={HTML5Backend}>\n    <ControlBar\n      algKeys={AlgKeys}\n      setAlg={setAlg}\n      runAlg={async () => { setAnimated(true); await runAlgorithmAnimated(AlgMap[alg], walls, source, dest) }}\n      clear={clear}\n      generateMaze={() => { \n        clear();\n        const newWalls = GenerateMaze(0, 0, WIDTH, HEIGHT, source, dest);\n        setWalls(newWalls);\n      }}\n    />\n    <Grid\n      setSource={setSource}\n      setDest={setDest}\n      setWall={setWall}\n      removeWall={removeWall}\n      getType={(coords) => getType(coords, walls, source, dest)}\n      handleRedrawOnReposition={(type, coords) => {\n        if (isAnimated) {\n          if (type === ItemTypes.SOURCE) {\n            runAlgorithmInstant(AlgMap[alg], walls, coords, dest);\n          } else if (type === ItemTypes.DEST) {\n            runAlgorithmInstant(AlgMap[alg], walls, source, coords);\n          }\n        }\n      }}\n    />\n  </DndProvider>\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}